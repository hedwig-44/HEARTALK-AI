# HearTalk ai-serviceåˆå¹¶ä¿®æ”¹è®°å½•ï¼ŒåŠAIå¯¹è¯è®°å¿†ç³»ç»Ÿåˆ†ææŠ¥å‘Š

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-09-18  
**åˆ†ææ—¶é—´**: å®é™…ç”¨æˆ·æµ‹è¯•åçš„æŠ€æœ¯è¯Šæ–­  
**é—®é¢˜ä¸¥é‡ç¨‹åº¦**: ğŸ”´ ä¸¥é‡ - æ ¸å¿ƒåŠŸèƒ½å®Œå…¨å¤±æ•ˆ

---

## ğŸ“Š æ‰§è¡Œæ‘˜è¦

### æ ¸å¿ƒé—®é¢˜
HearTalk AIç³»ç»Ÿçš„å¯¹è¯è®°å¿†åŠŸèƒ½å®Œå…¨å¤±æ•ˆï¼Œå¯¼è‡´AIæ— æ³•è®°ä½åŒä¸€å¯¹è¯ä¸­çš„ä»»ä½•å†å²ä¿¡æ¯ï¼Œä¸¥é‡å½±å“ç”¨æˆ·ä½“éªŒã€‚

### æµ‹è¯•ç»“æœ
- **çŸ­æœŸè®°å¿†**: 0/5 â­ (å®Œå…¨å¤±æ•ˆ)
- **é•¿ç¨‹è®°å¿†**: 0/5 â­ (å®Œå…¨å¤±æ•ˆ)  
- **ä¸Šä¸‹æ–‡å…³è”**: 0/5 â­ (å®Œå…¨å¤±æ•ˆ)
- **é€»è¾‘ä¸€è‡´æ€§**: 0/5 â­ (å®Œå…¨å¤±æ•ˆ)
- **å¤šè½®æ¨ç†**: 0/5 â­ (å®Œå…¨å¤±æ•ˆ)

### æ ¹æœ¬åŸå› 
AIæœåŠ¡è®¾è®¡äº†å®Œæ•´çš„ä¸Šä¸‹æ–‡ç®¡ç†æ¶æ„ï¼Œä½†åç«¯ç¼ºå°‘å¿…è¦çš„internal APIå®ç°ï¼Œå¯¼è‡´æ‰€æœ‰å†å²å¯¹è¯è·å–è¯·æ±‚å¤±è´¥ã€‚

---

## ğŸ” è¯¦ç»†æŠ€æœ¯åˆ†æ

### ç”¨æˆ·æµ‹è¯•æ¡ˆä¾‹

#### æµ‹è¯•æ¡†æ¶
é‡‡ç”¨æ ‡å‡†çš„å¯¹è¯AIè¯„ä¼°æ–¹æ³•ï¼ŒåŒ…å«5ä¸ªæ ¸å¿ƒèƒ½åŠ›æµ‹è¯•ï¼š

1. **çŸ­æœŸè®°å¿†æµ‹è¯•**
   - è¾“å…¥ï¼š`æˆ‘å«å°ç‹ï¼Œä»Šå¹´35å²ï¼Œæ˜¯ä¸ªåŒ»ç”Ÿ` â†’ `æˆ‘åˆšæ‰è¯´æˆ‘å¤šå¤§æ¥ç€ï¼Ÿ`
   - æœŸæœ›ï¼š`ä½ è¯´ä½ 35å²`
   - å®é™…ï¼šæä¾›äº†æŸ¥æ‰¾é—å¿˜ä¿¡æ¯çš„é€šç”¨å»ºè®®
   - ç»“æœï¼šâŒ å¤±è´¥

2. **é•¿ç¨‹è®°å¿†æµ‹è¯•**
   - è¾“å…¥ï¼š`ä½ æ˜¨å¤©ç»™æˆ‘æ¨èå“ªäº›è½¦æ¥çš„ï¼Ÿ`
   - æœŸæœ›ï¼šå›å¿†æ˜¨å¤©çš„è´­è½¦æ¨è
   - å®é™…ï¼š`æˆ‘æ— æ³•å‡†ç¡®å›å¿†èµ·æ˜¨å¤©ä¸ºä½ æ¨èçš„å…·ä½“è½¦å‹`
   - ç»“æœï¼šâŒ å¤±è´¥

3. **ä¸Šä¸‹æ–‡å…³è”æµ‹è¯•**
   - è¾“å…¥ï¼š`æˆ‘æœ‰ä¸¤ä¸ªæœ‹å‹ï¼Œå°æå’Œå°å¼ ã€‚å°ææ˜¯ç”»å®¶ï¼Œå°å¼ æ˜¯ç¨‹åºå‘˜` â†’ `å“ªä¸ªæ˜¯ç¨‹åºå‘˜ï¼Ÿ`
   - æœŸæœ›ï¼š`å°å¼ æ˜¯ç¨‹åºå‘˜`
   - å®é™…ï¼šç»™å‡ºç¨‹åºå‘˜çš„å®šä¹‰è€Œéç›´æ¥å›ç­”
   - ç»“æœï¼šâŒ å¤±è´¥

4. **é€»è¾‘ä¸€è‡´æ€§æµ‹è¯•**
   - è¾“å…¥ï¼šç«è½¦æ—¶é—´è®¡ç®—é¢˜ â†’ `ä½ åˆšæ‰ç®—çš„ç»“æœæ˜¯ä»€ä¹ˆï¼Ÿ`
   - ç¬¬ä¸€æ¬¡ï¼š`ä¸‹åˆ1ç‚¹` âœ…
   - ç¬¬äºŒæ¬¡ï¼š`æ²¡æœ‰å…·ä½“çš„è®¡ç®—å†…å®¹ï¼Œæ— æ³•æä¾›ä¹‹å‰çš„ç»“æœ` âŒ
   - ç»“æœï¼šâŒ è‡ªç›¸çŸ›ç›¾

5. **å¤šè½®æ¨ç†æµ‹è¯•**
   - è¾“å…¥ï¼šå® ç‰©ç‹—ä¿¡æ¯é“¾ `å‡è®¾æˆ‘æœ‰ä¸€ä¸ªå® ç‰©ç‹—ï¼Œå®ƒå–œæ¬¢åƒéª¨å¤´` â†’ `åˆšæ‰è¯´çš„å® ç‰©æ˜¯ä»€ä¹ˆï¼Ÿ`
   - æœŸæœ›ï¼šè®°ä½ç‹—å’Œéª¨å¤´çš„å…³è”
   - å®é™…ï¼šæ— æ³•è®°ä½ä»»ä½•å…ˆå‰ä¿¡æ¯
   - ç»“æœï¼šâŒ å¤±è´¥

### æŠ€æœ¯æ ¹å› åˆ†æ

#### æ•°æ®æµåˆ†æ
```mermaid
graph TD
    A[å‰ç«¯å‘é€æ¶ˆæ¯] --> B[åç«¯/conversations/:id/ai-message]
    B --> C[AIæœåŠ¡ChatController.generateChat]
    C --> D[ContextManager.getConversationContext]
    D --> E[BackendApiClient.getConversationHistory]
    E --> F[HTTP GET /internal/api/v1/conversations/:id/history]
    F --> G[âŒ 404 Route not found]
    G --> H[è¿”å›ç©ºä¸Šä¸‹æ–‡ context: []]
    H --> I[AIå¤±å»æ‰€æœ‰è®°å¿†]
```

#### å…³é”®å‘ç°

1. **æ¶æ„è®¾è®¡å®Œæ•´**
   - âœ… ContextManager è®¾è®¡åˆç†
   - âœ… BackendApiClient å®ç°æ ‡å‡†
   - âœ… ç¼“å­˜æœºåˆ¶å®Œå–„
   - âœ… é”™è¯¯å¤„ç†æœºåˆ¶å­˜åœ¨

2. **å®ç°ç¼ºå¤±**
   - âŒ åç«¯ç¼ºå°‘ `/internal/api/v1/conversations/:id/history` API
   - âŒ åç«¯ç¼ºå°‘ `/internal/api/v1/users/:id/context` API
   - âŒ æ— æ³•è·å–å†å²å¯¹è¯æ•°æ®

3. **éªŒè¯ç»“æœ**
   ```bash
   curl http://localhost:8000/internal/api/v1/conversations/xxx/history
   # è¿”å›ï¼š{"success": false, "error": "Route not found"}
   ```

#### ä»£ç å±‚é¢åˆ†æ

**ContextManager.js (Line 107)**
```javascript
const result = await this.backendClient.getConversationHistory(conversationId);
// è¿™ä¸ªè°ƒç”¨ä¼šè¿”å› 404 é”™è¯¯
```

**BackendApiClient.js (Line 169-171)**
```javascript
const response = await this.httpClient.get(
  `${this.apiPrefix}${this.conversationPath}/${conversationId}/history`
);
// è¯·æ±‚ /internal/api/v1/conversations/:id/history - ä¸å­˜åœ¨
```

**ChatController.js (Line 94-123)**
```javascript
// å½“ä¸Šä¸‹æ–‡è·å–å¤±è´¥æ—¶ï¼Œä¼šè®°å½•è­¦å‘Šä½†ç»§ç»­å¤„ç†
// ç»“æœï¼šAIæ¥æ”¶åˆ°ç©ºçš„ conversationHistory = []
```

---

## ğŸš€ ä¼˜åŒ–æ–¹æ¡ˆ

### æ–¹æ¡ˆä¸€ï¼šç´§æ€¥ä¿®å¤æ–¹æ¡ˆ (1-2å¤©å®æ–½)

#### æ ¸å¿ƒæ€è·¯
åœ¨AIæœåŠ¡å†…éƒ¨å®ç°ä¸´æ—¶çš„å¯¹è¯è®°å¿†å­˜å‚¨ï¼Œæ— éœ€ä¿®æ”¹åç«¯ã€‚

#### æŠ€æœ¯å®ç°

**1. æ·»åŠ å†…å­˜å­˜å‚¨**
```javascript
// ChatController.js
class ChatController {
  constructor() {
    // å…¨å±€å¯¹è¯è®°å¿†å­˜å‚¨
    this.conversationMemory = new Map();
    // æ ¼å¼ï¼šconversationId -> [{role, content, timestamp}]
  }
}
```

**2. ä¿®æ”¹ä¸Šä¸‹æ–‡è·å–é€»è¾‘**
```javascript
async generateChat(req, res) {
  // å°è¯•ä»åç«¯è·å–ï¼Œå¤±è´¥åˆ™ä½¿ç”¨å†…å­˜å­˜å‚¨
  let conversationHistory = [];
  
  if (validationResult.format === 'openai') {
    conversationHistory = options.messages || [];
  } else {
    try {
      const contextResult = await this.contextManager.getConversationContext(
        conversation_id, user_id
      );
      conversationHistory = contextResult.data?.messages || [];
    } catch (error) {
      // å›é€€åˆ°å†…å­˜å­˜å‚¨
      conversationHistory = this.getFromMemory(conversation_id);
    }
  }
  
  // ... å¤„ç†AIè¯·æ±‚
  
  // ä¿å­˜æœ¬æ¬¡å¯¹è¯åˆ°å†…å­˜
  this.saveToMemory(conversation_id, {
    role: 'user',
    content: message,
    timestamp: new Date()
  });
  
  this.saveToMemory(conversation_id, {
    role: 'assistant', 
    content: response.data.content,
    timestamp: new Date()
  });
}
```

**3. å†…å­˜ç®¡ç†æ–¹æ³•**
```javascript
getFromMemory(conversationId) {
  return this.conversationMemory.get(conversationId) || [];
}

saveToMemory(conversationId, message) {
  if (!this.conversationMemory.has(conversationId)) {
    this.conversationMemory.set(conversationId, []);
  }
  
  const messages = this.conversationMemory.get(conversationId);
  messages.push(message);
  
  // é™åˆ¶å†…å­˜ä½¿ç”¨ï¼Œä¿ç•™æœ€è¿‘50æ¡æ¶ˆæ¯
  if (messages.length > 50) {
    messages.splice(0, messages.length - 50);
  }
}
```

#### ä¼˜åŠ¿ä¸åŠ£åŠ¿
- âœ… **ä¼˜åŠ¿**: å¿«é€Ÿå®ç°ï¼Œæ— éœ€åç«¯æ”¹åŠ¨ï¼Œç«‹å³è§£å†³ç”¨æˆ·ä½“éªŒé—®é¢˜
- âŒ **åŠ£åŠ¿**: é‡å¯æœåŠ¡ä¸¢å¤±æ•°æ®ï¼Œå†…å­˜å ç”¨ï¼Œæ— æ³•è·¨æœåŠ¡å®ä¾‹å…±äº«

#### å®æ–½æ­¥éª¤
1. ä¿®æ”¹ `ccpm/ai-service/src/controllers/ChatController.js`
2. æ·»åŠ å†…å­˜å­˜å‚¨å’Œç®¡ç†æ–¹æ³•
3. ä¿®æ”¹ä¸Šä¸‹æ–‡è·å–é€»è¾‘
4. åŒæ­¥åˆ° HEARTALK-BE é¡¹ç›®
5. é‡å¯AIæœåŠ¡è¿›è¡Œæµ‹è¯•

---

### æ–¹æ¡ˆäºŒï¼šä¸­æœŸæ”¹è¿›æ–¹æ¡ˆ (1-2å‘¨å®æ–½)

#### æ ¸å¿ƒæ€è·¯
å®ç°å®Œæ•´çš„åç«¯internal APIï¼Œæä¾›æ ‡å‡†çš„å¯¹è¯å†å²æœåŠ¡ã€‚

#### æŠ€æœ¯å®ç°

**1. åç«¯æ·»åŠ internal APIè·¯ç”±**
```javascript
// backend/src/routes/internal.js
const express = require('express');
const router = express.Router();

// éªŒè¯internal API key
const validateInternalApiKey = (req, res, next) => {
  const apiKey = req.headers['x-api-key'];
  if (apiKey === process.env.HEARTALK_API_KEY) {
    next();
  } else {
    res.status(401).json({ 
      success: false, 
      error: 'Invalid API key' 
    });
  }
};

// è·å–å¯¹è¯å†å²
router.get('/conversations/:id/history', 
  validateInternalApiKey,
  async (req, res) => {
    try {
      const conversationId = req.params.id;
      const limit = parseInt(req.query.limit) || 20;
      
      const messages = await messageService.getByConversationId(
        conversationId, 
        { limit, orderBy: 'created_at', order: 'ASC' }
      );
      
      res.json({
        success: true,
        data: messages.map(msg => ({
          role: msg.role,
          content: msg.content,
          timestamp: msg.created_at
        }))
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: 'Failed to fetch conversation history'
      });
    }
  }
);

// è·å–ç”¨æˆ·ä¸Šä¸‹æ–‡
router.get('/users/:id/context',
  validateInternalApiKey, 
  async (req, res) => {
    try {
      const userId = req.params.id;
      const user = await userService.getById(userId);
      
      res.json({
        success: true,
        data: {
          user: {
            id: user.id,
            name: user.name,
            preferences: user.preferences
          },
          recentTopics: [], // å¯æ‰©å±•
          userProfile: {}   // å¯æ‰©å±•
        }
      });
    } catch (error) {
      res.status(500).json({
        success: false,
        error: 'Failed to fetch user context'
      });
    }
  }
);

module.exports = router;
```

**2. æ³¨å†Œinternalè·¯ç”±**
```javascript
// backend/src/app.js
const internalRoutes = require('./routes/internal');
app.use('/internal/api/v1', internalRoutes);
```

**3. æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–**
```javascript
// backend/src/services/messageService.js
async getByConversationId(conversationId, options = {}) {
  const { limit = 20, orderBy = 'created_at', order = 'ASC' } = options;
  
  const query = `
    SELECT id, role, content, metadata, created_at
    FROM messages 
    WHERE conversation_id = $1 
    ORDER BY ${orderBy} ${order}
    LIMIT $2
  `;
  
  const result = await pool.query(query, [conversationId, limit]);
  return result.rows;
}
```

#### ä¼˜åŠ¿ä¸åŠ£åŠ¿
- âœ… **ä¼˜åŠ¿**: å®Œæ•´æ¶æ„ï¼ŒæŒä¹…åŒ–å­˜å‚¨ï¼Œæ”¯æŒåˆ†å¸ƒå¼ï¼Œå¯æ‰©å±•
- âŒ **åŠ£åŠ¿**: éœ€è¦åç«¯å¼€å‘å·¥ä½œï¼Œå®æ–½å‘¨æœŸè¾ƒé•¿

#### å®æ–½æ­¥éª¤
1. åˆ›å»º `backend/src/routes/internal.js`
2. å®ç°å¯¹è¯å†å²å’Œç”¨æˆ·ä¸Šä¸‹æ–‡API
3. æ·»åŠ è®¤è¯å’Œé”™è¯¯å¤„ç†
4. æ›´æ–°è·¯ç”±æ³¨å†Œ
5. æµ‹è¯•APIåŠŸèƒ½
6. éƒ¨ç½²æ›´æ–°

---

### æ–¹æ¡ˆä¸‰ï¼šé•¿æœŸæ¶æ„æ–¹æ¡ˆ (1-2æœˆå®æ–½)

#### æ ¸å¿ƒæ€è·¯
å»ºè®¾æ™ºèƒ½åŒ–çš„å¯¹è¯ä¸Šä¸‹æ–‡ç®¡ç†ç³»ç»Ÿï¼Œæä¾›é«˜çº§è®°å¿†å’Œæ¨ç†èƒ½åŠ›ã€‚

#### é«˜çº§ç‰¹æ€§

**1. æ™ºèƒ½ä¸Šä¸‹æ–‡å‹ç¼©**
```javascript
class SmartContextManager {
  async compressContext(messages, maxTokens = 2000) {
    // ä½¿ç”¨AIæ€»ç»“é•¿å¯¹è¯å†å²
    const summary = await this.aiSummarizer.summarize(messages, {
      preserveEntities: true,
      preserveKeyEvents: true,
      maxLength: maxTokens * 0.3
    });
    
    // ä¿ç•™æœ€è¿‘çš„è¯¦ç»†æ¶ˆæ¯
    const recentMessages = messages.slice(-10);
    
    return {
      summary: summary,
      recentMessages: recentMessages,
      totalOriginalMessages: messages.length
    };
  }
}
```

**2. å®ä½“å…³ç³»è¿½è¸ª**
```javascript
class EntityTracker {
  constructor() {
    this.entityGraph = new Map(); // å®ä½“å…³ç³»å›¾
  }
  
  track(message) {
    // æå–å®ä½“
    const entities = this.extractEntities(message);
    
    // å»ºç«‹å…³ç³»
    entities.forEach(entity => {
      this.updateEntityRelations(entity, message.context);
    });
  }
  
  query(entityName) {
    // æŸ¥è¯¢å®ä½“ç›¸å…³ä¿¡æ¯
    return this.entityGraph.get(entityName);
  }
}
```

**3. ä¸Šä¸‹æ–‡ç›¸å…³æ€§è¯„åˆ†**
```javascript
class ContextRelevanceScorer {
  scoreRelevance(currentMessage, historicalMessage) {
    let score = 0;
    
    // æ—¶é—´è¡°å‡
    const timeDiff = Date.now() - historicalMessage.timestamp;
    const timeScore = Math.exp(-timeDiff / (24 * 60 * 60 * 1000)); // 24å°æ—¶è¡°å‡
    
    // ä¸»é¢˜ç›¸ä¼¼æ€§
    const topicScore = this.calculateTopicSimilarity(
      currentMessage.content, 
      historicalMessage.content
    );
    
    // å®ä½“é‡å 
    const entityScore = this.calculateEntityOverlap(
      currentMessage.entities,
      historicalMessage.entities
    );
    
    return (timeScore * 0.3 + topicScore * 0.4 + entityScore * 0.3);
  }
}
```

**4. å¤šå±‚æ¬¡è®°å¿†ç³»ç»Ÿ**
```javascript
class MultiLayerMemory {
  constructor() {
    this.shortTerm = new LRUCache(100);     // æœ€è¿‘100æ¡æ¶ˆæ¯
    this.mediumTerm = new Map();            // ä¼šè¯çº§æ‘˜è¦
    this.longTerm = new VectorDatabase();   // å‘é‡åŒ–å­˜å‚¨
  }
  
  async store(conversationId, message) {
    // çŸ­æœŸè®°å¿†
    this.shortTerm.set(`${conversationId}_${Date.now()}`, message);
    
    // ä¸­æœŸè®°å¿† - ä¼šè¯æ‘˜è¦
    if (!this.mediumTerm.has(conversationId)) {
      this.mediumTerm.set(conversationId, {
        summary: '',
        keyEntities: new Set(),
        topics: new Set()
      });
    }
    
    // é•¿æœŸè®°å¿† - å‘é‡åŒ–å­˜å‚¨
    const embedding = await this.generateEmbedding(message.content);
    await this.longTerm.store(embedding, message);
  }
  
  async retrieve(conversationId, query, options = {}) {
    const results = [];
    
    // ä»çŸ­æœŸè®°å¿†è·å–
    const shortTermResults = this.shortTerm.get(conversationId) || [];
    results.push(...shortTermResults);
    
    // ä»é•¿æœŸè®°å¿†è¯­ä¹‰æœç´¢
    if (options.includeLongTerm) {
      const queryEmbedding = await this.generateEmbedding(query);
      const longTermResults = await this.longTerm.search(queryEmbedding, {
        limit: 5,
        threshold: 0.7
      });
      results.push(...longTermResults);
    }
    
    // æŒ‰ç›¸å…³æ€§æ’åº
    return this.rankByRelevance(results, query);
  }
}
```

#### ä¼˜åŠ¿ä¸åŠ£åŠ¿
- âœ… **ä¼˜åŠ¿**: æ™ºèƒ½åŒ–ç¨‹åº¦é«˜ï¼Œç”¨æˆ·ä½“éªŒæä½³ï¼Œå¯æ”¯æŒå¤æ‚æ¨ç†
- âŒ **åŠ£åŠ¿**: å¼€å‘å¤æ‚åº¦é«˜ï¼Œéœ€è¦æ›´å¤šAIæ¨¡å‹å’Œè®¡ç®—èµ„æº

#### è¯¦ç»†å®æ–½æ­¥éª¤

##### **Phase 1: åŸºç¡€æ™ºèƒ½åŠŸèƒ½ (3-4å‘¨)**

**Step 1.1: å®ä½“è¿½è¸ªç³»ç»Ÿ (Week 1-2)**
```bash
# åˆ›å»ºå®ä½“è¿½è¸ªç»„ä»¶
mkdir -p ai-service/src/services/smart-context
touch ai-service/src/services/smart-context/EntityTracker.js
```

**æ ¸å¿ƒå®ç°**:
```javascript
// ai-service/src/services/smart-context/EntityTracker.js
export class EntityTracker {
  constructor() {
    this.entityGraph = new Map();
    this.nlpProcessor = new NLPProcessor();
  }
  
  async extractEntities(message) {
    // ä½¿ç”¨è‡ªç„¶è¯­è¨€å¤„ç†æå–å®ä½“
    const entities = await this.nlpProcessor.extractEntities(message);
    return entities.filter(entity => entity.confidence > 0.7);
  }
  
  buildRelationships(entities, conversationContext) {
    entities.forEach(entity => {
      this.updateEntityGraph(entity, conversationContext);
    });
  }
  
  queryEntityContext(entityName) {
    return this.entityGraph.get(entityName) || {
      relationships: [],
      mentions: [],
      attributes: {}
    };
  }
}
```

**Step 1.2: ä¸Šä¸‹æ–‡ç›¸å…³æ€§è¯„åˆ† (Week 2)**
```javascript
// ai-service/src/services/smart-context/ContextRelevanceScorer.js
export class ContextRelevanceScorer {
  scoreRelevance(currentMessage, historicalMessage) {
    // æ—¶é—´è¡°å‡å› å­ (24å°æ—¶å†…æƒé‡æœ€é«˜)
    const timeDiff = Date.now() - historicalMessage.timestamp;
    const timeScore = Math.exp(-timeDiff / (24 * 60 * 60 * 1000));
    
    // ä¸»é¢˜ç›¸ä¼¼æ€§ (å…³é”®è¯é‡å )
    const topicScore = this.calculateTopicSimilarity(
      currentMessage.content, 
      historicalMessage.content
    );
    
    // å®ä½“é‡å åº¦
    const entityScore = this.calculateEntityOverlap(
      currentMessage.entities || [],
      historicalMessage.entities || []
    );
    
    // ç»¼åˆè¯„åˆ† (æƒé‡å¯è°ƒ)
    return (timeScore * 0.3 + topicScore * 0.4 + entityScore * 0.3);
  }
  
  rankContexts(contexts, query) {
    return contexts
      .map(ctx => ({
        ...ctx,
        relevanceScore: this.scoreRelevance(query, ctx)
      }))
      .sort((a, b) => b.relevanceScore - a.relevanceScore)
      .slice(0, 10); // ä¿ç•™å‰10ä¸ªæœ€ç›¸å…³çš„ä¸Šä¸‹æ–‡
  }
}
```

**Step 1.3: åŸºç¡€å‘é‡å­˜å‚¨ (Week 3)**
```javascript
// ai-service/src/services/smart-context/VectorMemoryStore.js
export class VectorMemoryStore {
  constructor() {
    this.vectorDB = new Map(); // ç®€åŒ–å®ç°ï¼Œåç»­å¯æ›¿æ¢ä¸ºä¸“ä¸šå‘é‡æ•°æ®åº“
    this.embeddingCache = new LRUCache(1000);
  }
  
  async generateEmbedding(text) {
    if (this.embeddingCache.has(text)) {
      return this.embeddingCache.get(text);
    }
    
    // ä½¿ç”¨ç®€åŒ–çš„å‘é‡åŒ–æ–¹æ³• (å¯åç»­æ›¿æ¢ä¸ºæ›´é«˜çº§çš„æ¨¡å‹)
    const embedding = await this.textToVector(text);
    this.embeddingCache.set(text, embedding);
    return embedding;
  }
  
  async store(messageId, text, metadata = {}) {
    const embedding = await this.generateEmbedding(text);
    this.vectorDB.set(messageId, {
      embedding,
      text,
      metadata,
      timestamp: Date.now()
    });
  }
  
  async search(query, limit = 5, threshold = 0.7) {
    const queryEmbedding = await this.generateEmbedding(query);
    
    const results = [];
    for (const [id, data] of this.vectorDB.entries()) {
      const similarity = this.cosineSimilarity(queryEmbedding, data.embedding);
      if (similarity >= threshold) {
        results.push({
          id,
          similarity,
          ...data
        });
      }
    }
    
    return results
      .sort((a, b) => b.similarity - a.similarity)
      .slice(0, limit);
  }
}
```

**Step 1.4: é›†æˆåˆ°ChatController (Week 4)**
```javascript
// ä¿®æ”¹ ai-service/src/controllers/ChatController.js
import { EntityTracker } from '../services/smart-context/EntityTracker.js';
import { ContextRelevanceScorer } from '../services/smart-context/ContextRelevanceScorer.js';
import { VectorMemoryStore } from '../services/smart-context/VectorMemoryStore.js';

export class ChatController {
  constructor() {
    // ç°æœ‰åˆå§‹åŒ–...
    
    // æ–°å¢æ™ºèƒ½ä¸Šä¸‹æ–‡ç»„ä»¶
    this.entityTracker = new EntityTracker();
    this.relevanceScorer = new ContextRelevanceScorer();
    this.vectorMemory = new VectorMemoryStore();
  }
  
  async generateChat(req, res) {
    // ... ç°æœ‰ä»£ç 
    
    // Phase 1: æ™ºèƒ½ä¸Šä¸‹æ–‡å¢å¼º
    try {
      // æå–å½“å‰æ¶ˆæ¯çš„å®ä½“
      const currentEntities = await this.entityTracker.extractEntities(message);
      
      // ä»å‘é‡å†…å­˜ä¸­æœç´¢ç›¸å…³å†å²
      const relevantHistory = await this.vectorMemory.search(message, 5, 0.6);
      
      // åˆå¹¶ä¼ ç»Ÿä¸Šä¸‹æ–‡å’Œæ™ºèƒ½ä¸Šä¸‹æ–‡
      const enhancedContext = this.mergeContexts(
        conversationHistory,
        relevantHistory,
        currentEntities
      );
      
      // å­˜å‚¨å½“å‰æ¶ˆæ¯åˆ°å‘é‡å†…å­˜
      await this.vectorMemory.store(
        `${conversation_id}_${Date.now()}`,
        message,
        { userId: user_id, entities: currentEntities }
      );
      
      // ä½¿ç”¨å¢å¼ºçš„ä¸Šä¸‹æ–‡è¿›è¡ŒAIæ¨ç†
      const response = await this.reasoningEnhancer.enhanceReasoning({
        message,
        context: enhancedContext,
        entities: currentEntities,
        aiProvider: this.provider
      });
      
      // ... å“åº”å¤„ç†
    } catch (error) {
      logger.warn('Smart context processing failed, falling back to basic mode', {
        error: error.message
      });
      // å›é€€åˆ°åŸºç¡€æ¨¡å¼
    }
  }
}
```

##### **Phase 2: é«˜çº§æ™ºèƒ½åŠŸèƒ½ (4-5å‘¨)**

**Step 2.1: æ™ºèƒ½ä¸Šä¸‹æ–‡å‹ç¼©å™¨ (Week 5-6)**
```javascript
// ai-service/src/services/smart-context/SmartContextCompressor.js
export class SmartContextCompressor {
  constructor() {
    this.maxTokens = 2000;
    this.summaryModel = 'gpt-3.5-turbo'; // å¯é…ç½®
  }
  
  async compress(messages, options = {}) {
    const { preserveEntities = [], maxTokens = this.maxTokens } = options;
    
    if (this.estimateTokens(messages) <= maxTokens) {
      return { compressed: false, messages };
    }
    
    // åˆ†æ®µå‹ç¼©ç­–ç•¥
    const segments = this.segmentMessages(messages);
    const compressedSegments = [];
    
    for (const segment of segments) {
      if (segment.importance === 'high') {
        // é«˜é‡è¦æ€§æ¶ˆæ¯ä¿ç•™åŸæ–‡
        compressedSegments.push(...segment.messages);
      } else {
        // ä½é‡è¦æ€§æ¶ˆæ¯è¿›è¡Œæ‘˜è¦
        const summary = await this.summarizeSegment(segment.messages, preserveEntities);
        compressedSegments.push({
          role: 'system',
          content: `[æ‘˜è¦] ${summary}`,
          metadata: { compressed: true, originalCount: segment.messages.length }
        });
      }
    }
    
    return {
      compressed: true,
      messages: compressedSegments,
      compressionRatio: messages.length / compressedSegments.length
    };
  }
  
  async summarizeSegment(messages, preserveEntities) {
    const prompt = `
è¯·å°†ä»¥ä¸‹å¯¹è¯å†…å®¹æ€»ç»“ä¸ºç®€æ´çš„æ‘˜è¦ï¼Œä¿ç•™å…³é”®ä¿¡æ¯å’Œä»¥ä¸‹å®ä½“ï¼š${preserveEntities.join(', ')}

å¯¹è¯å†…å®¹ï¼š
${messages.map(m => `${m.role}: ${m.content}`).join('\n')}

æ‘˜è¦è¦æ±‚ï¼š
1. ä¿ç•™é‡è¦çš„äº‹å®å’Œå†³å®š
2. ä¿ç•™æåˆ°çš„äººç‰©ã€åœ°ç‚¹ã€æ—¶é—´
3. ä¿ç•™å…³é”®çš„æƒ…æ„Ÿå’Œæ€åº¦
4. æ§åˆ¶åœ¨100å­—ä»¥å†…
`;
    
    // è°ƒç”¨AIæ¨¡å‹è¿›è¡Œæ‘˜è¦
    const summary = await this.callSummaryModel(prompt);
    return summary;
  }
}
```

**Step 2.2: å¤šå±‚æ¬¡è®°å¿†ç³»ç»Ÿ (Week 6-7)**
```javascript
// ai-service/src/services/smart-context/MultiLayerMemory.js
export class MultiLayerMemory {
  constructor() {
    this.shortTerm = new LRUCache(100);      // æœ€è¿‘100æ¡æ¶ˆæ¯
    this.mediumTerm = new Map();             // ä¼šè¯çº§æ‘˜è¦
    this.longTerm = new VectorMemoryStore(); // é•¿æœŸå‘é‡å­˜å‚¨
  }
  
  async store(conversationId, message, metadata = {}) {
    const messageId = `${conversationId}_${Date.now()}`;
    const enrichedMessage = {
      ...message,
      ...metadata,
      timestamp: Date.now()
    };
    
    // çŸ­æœŸè®°å¿† - ç›´æ¥å­˜å‚¨
    this.shortTerm.set(messageId, enrichedMessage);
    
    // ä¸­æœŸè®°å¿† - æ›´æ–°ä¼šè¯æ‘˜è¦
    await this.updateSessionSummary(conversationId, message);
    
    // é•¿æœŸè®°å¿† - å‘é‡åŒ–å­˜å‚¨
    await this.longTerm.store(messageId, message.content, {
      conversationId,
      role: message.role,
      entities: metadata.entities || [],
      timestamp: enrichedMessage.timestamp
    });
  }
  
  async retrieve(conversationId, query, options = {}) {
    const {
      includeShortTerm = true,
      includeMediumTerm = true,
      includeLongTerm = false,
      maxResults = 10
    } = options;
    
    let results = [];
    
    // çŸ­æœŸè®°å¿†æ£€ç´¢
    if (includeShortTerm) {
      const shortTermResults = Array.from(this.shortTerm.values())
        .filter(msg => msg.conversationId === conversationId)
        .slice(-20); // æœ€è¿‘20æ¡
      results.push(...shortTermResults);
    }
    
    // ä¸­æœŸè®°å¿†æ£€ç´¢  
    if (includeMediumTerm) {
      const sessionSummary = this.mediumTerm.get(conversationId);
      if (sessionSummary) {
        results.push({
          role: 'system',
          content: sessionSummary.summary,
          metadata: { type: 'session_summary' }
        });
      }
    }
    
    // é•¿æœŸè®°å¿†æ£€ç´¢ (è¯­ä¹‰æœç´¢)
    if (includeLongTerm) {
      const longTermResults = await this.longTerm.search(query, 5, 0.6);
      results.push(...longTermResults.map(r => ({
        role: 'assistant',
        content: r.text,
        metadata: { 
          type: 'long_term_memory',
          similarity: r.similarity,
          ...r.metadata
        }
      })));
    }
    
    // æŒ‰ç›¸å…³æ€§å’Œæ—¶é—´æ’åº
    return this.rankAndLimit(results, query, maxResults);
  }
  
  async updateSessionSummary(conversationId, newMessage) {
    let summary = this.mediumTerm.get(conversationId) || {
      summary: '',
      keyEntities: new Set(),
      topics: new Set(),
      messageCount: 0
    };
    
    // å¢é‡æ›´æ–°æ‘˜è¦
    summary.messageCount++;
    
    // æ¯10æ¡æ¶ˆæ¯é‡æ–°ç”Ÿæˆæ‘˜è¦
    if (summary.messageCount % 10 === 0) {
      const recentMessages = Array.from(this.shortTerm.values())
        .filter(msg => msg.conversationId === conversationId)
        .slice(-10);
      
      summary.summary = await this.generateSessionSummary(recentMessages);
    }
    
    this.mediumTerm.set(conversationId, summary);
  }
}
```

**Step 2.3: å®ä½“å…³ç³»å›¾è°± (Week 8-9)**
```javascript
// ai-service/src/services/smart-context/EntityGraphManager.js
export class EntityGraphManager {
  constructor() {
    this.entityGraph = new Map(); // å®ä½“å›¾è°±
    this.relationshipTypes = {
      'knows': { weight: 0.8, decay: 0.95 },
      'related_to': { weight: 0.6, decay: 0.98 },
      'mentioned_with': { weight: 0.4, decay: 0.99 }
    };
  }
  
  addEntity(entity) {
    if (!this.entityGraph.has(entity.id)) {
      this.entityGraph.set(entity.id, {
        ...entity,
        relationships: new Map(),
        lastMentioned: Date.now(),
        mentionCount: 0
      });
    }
    
    // æ›´æ–°æåŠä¿¡æ¯
    const entityNode = this.entityGraph.get(entity.id);
    entityNode.lastMentioned = Date.now();
    entityNode.mentionCount++;
  }
  
  addRelationship(entity1Id, entity2Id, relationshipType, context) {
    const entity1 = this.entityGraph.get(entity1Id);
    const entity2 = this.entityGraph.get(entity2Id);
    
    if (!entity1 || !entity2) return;
    
    const relationshipConfig = this.relationshipTypes[relationshipType] || 
                              this.relationshipTypes['mentioned_with'];
    
    // åŒå‘å…³ç³»
    this.updateRelationship(entity1, entity2Id, relationshipType, relationshipConfig, context);
    this.updateRelationship(entity2, entity1Id, relationshipType, relationshipConfig, context);
  }
  
  getRelatedEntities(entityId, maxDepth = 2, minWeight = 0.3) {
    const visited = new Set();
    const result = [];
    
    const traverse = (currentId, depth, path) => {
      if (depth > maxDepth || visited.has(currentId)) return;
      
      visited.add(currentId);
      const entity = this.entityGraph.get(currentId);
      
      if (!entity) return;
      
      for (const [relatedId, relationship] of entity.relationships) {
        if (relationship.weight >= minWeight) {
          result.push({
            entity: this.entityGraph.get(relatedId),
            relationship: relationship,
            path: [...path, currentId],
            depth: depth
          });
          
          traverse(relatedId, depth + 1, [...path, currentId]);
        }
      }
    };
    
    traverse(entityId, 0, []);
    return result.sort((a, b) => b.relationship.weight - a.relationship.weight);
  }
  
  // æ—¶é—´è¡°å‡æ›´æ–°
  decayRelationships() {
    const now = Date.now();
    const oneDayMs = 24 * 60 * 60 * 1000;
    
    for (const [entityId, entity] of this.entityGraph) {
      for (const [relatedId, relationship] of entity.relationships) {
        const daysSinceUpdate = (now - relationship.lastUpdated) / oneDayMs;
        const decayRate = this.relationshipTypes[relationship.type]?.decay || 0.99;
        
        relationship.weight *= Math.pow(decayRate, daysSinceUpdate);
        
        // æ¸…ç†æƒé‡è¿‡ä½çš„å…³ç³»
        if (relationship.weight < 0.1) {
          entity.relationships.delete(relatedId);
        }
      }
    }
  }
}
```

##### **Phase 3: ä¼˜åŒ–å’Œé›†æˆ (2-3å‘¨)**

**Step 3.1: æ€§èƒ½ä¼˜åŒ– (Week 10)**
```javascript
// ai-service/src/services/smart-context/PerformanceOptimizer.js
export class PerformanceOptimizer {
  constructor() {
    this.cacheConfig = {
      entityExtraction: { ttl: 3600, maxSize: 1000 },
      contextRelevance: { ttl: 1800, maxSize: 500 },
      vectorSearch: { ttl: 600, maxSize: 200 }
    };
    
    this.caches = {
      entityExtraction: new LRUCache(this.cacheConfig.entityExtraction),
      contextRelevance: new LRUCache(this.cacheConfig.contextRelevance),
      vectorSearch: new LRUCache(this.cacheConfig.vectorSearch)
    };
  }
  
  async optimizeContextRetrieval(conversationId, query) {
    // å¹¶è¡Œæ‰§è¡Œå¤šä¸ªä¸Šä¸‹æ–‡æ£€ç´¢ä»»åŠ¡
    const [shortTermContext, vectorContext, entityContext] = await Promise.all([
      this.getShortTermContext(conversationId),
      this.getVectorContext(query),
      this.getEntityContext(query)
    ]);
    
    // åˆå¹¶å’Œå»é‡
    return this.mergeAndDeduplicate([
      ...shortTermContext,
      ...vectorContext, 
      ...entityContext
    ]);
  }
  
  // æ‰¹å¤„ç†å®ä½“æå–
  async batchEntityExtraction(messages) {
    const uncachedMessages = messages.filter(msg => 
      !this.caches.entityExtraction.has(msg.content)
    );
    
    if (uncachedMessages.length === 0) {
      return messages.map(msg => this.caches.entityExtraction.get(msg.content));
    }
    
    // æ‰¹é‡å¤„ç†
    const batchResults = await this.entityExtractor.extractBatch(
      uncachedMessages.map(msg => msg.content)
    );
    
    // ç¼“å­˜ç»“æœ
    batchResults.forEach((result, index) => {
      this.caches.entityExtraction.set(uncachedMessages[index].content, result);
    });
    
    return messages.map(msg => this.caches.entityExtraction.get(msg.content));
  }
}
```

**Step 3.2: ç›‘æ§å’Œè°ƒè¯•å·¥å…· (Week 11)**
```javascript
// ai-service/src/utils/SmartContextDebugger.js
export class SmartContextDebugger {
  constructor() {
    this.metrics = {
      entityExtractionTime: [],
      contextRetrievalTime: [],
      relevanceScores: [],
      compressionRatios: []
    };
  }
  
  logEntityExtraction(message, entities, processingTime) {
    this.metrics.entityExtractionTime.push(processingTime);
    
    logger.debug('Entity extraction completed', {
      messageLength: message.length,
      entitiesFound: entities.length,
      processingTime: `${processingTime}ms`,
      entities: entities.map(e => ({ name: e.name, type: e.type, confidence: e.confidence }))
    });
  }
  
  visualizeEntityGraph(userId, outputPath) {
    // ç”Ÿæˆå®ä½“å…³ç³»å›¾çš„å¯è§†åŒ–æ•°æ®
    const graphData = this.entityGraphManager.exportGraph(userId);
    
    // ç”ŸæˆDOTæ ¼å¼ç”¨äºGraphvizå¯è§†åŒ–
    const dotContent = this.generateDotGraph(graphData);
    
    // ä¿å­˜åˆ°æ–‡ä»¶
    fs.writeFileSync(outputPath, dotContent);
    
    logger.info('Entity graph visualization saved', { 
      path: outputPath,
      nodeCount: graphData.nodes.length,
      edgeCount: graphData.edges.length
    });
  }
  
  analyzeContextRelevance(contexts, query) {
    const scores = contexts.map(ctx => ctx.relevanceScore);
    const analysis = {
      averageScore: scores.reduce((a, b) => a + b, 0) / scores.length,
      maxScore: Math.max(...scores),
      minScore: Math.min(...scores),
      distribution: this.calculateDistribution(scores)
    };
    
    logger.debug('Context relevance analysis', {
      query: query.substring(0, 50),
      contextCount: contexts.length,
      ...analysis
    });
    
    return analysis;
  }
  
  generatePerformanceReport() {
    return {
      entityExtraction: {
        averageTime: this.average(this.metrics.entityExtractionTime),
        p95Time: this.percentile(this.metrics.entityExtractionTime, 95)
      },
      contextRetrieval: {
        averageTime: this.average(this.metrics.contextRetrievalTime),
        p95Time: this.percentile(this.metrics.contextRetrievalTime, 95)
      },
      relevanceScores: {
        average: this.average(this.metrics.relevanceScores),
        distribution: this.calculateDistribution(this.metrics.relevanceScores)
      },
      compressionRatios: {
        average: this.average(this.metrics.compressionRatios),
        maxRatio: Math.max(...this.metrics.compressionRatios)
      }
    };
  }
}
```

**Step 3.3: å®Œæ•´æµ‹è¯•å¥—ä»¶ (Week 12)**
```javascript
// ai-service/tests/smart-context/integration.test.js
describe('Smart Context Integration Tests', () => {
  let chatController, testUserId, testConversationId;
  
  beforeEach(async () => {
    chatController = new ChatController();
    testUserId = 'test-user-123';
    testConversationId = 'test-conv-456';
  });
  
  describe('Entity Tracking Across Conversations', () => {
    test('should remember entities mentioned in previous messages', async () => {
      // ç¬¬ä¸€æ¡æ¶ˆæ¯ï¼šæåˆ°å®ä½“
      await chatController.processMessage({
        conversationId: testConversationId,
        userId: testUserId,
        message: 'æˆ‘æœ‰ä¸¤ä¸ªæœ‹å‹ï¼Œå°ææ˜¯ç”»å®¶ï¼Œå°å¼ æ˜¯ç¨‹åºå‘˜ã€‚'
      });
      
      // ç¬¬äºŒæ¡æ¶ˆæ¯ï¼šè¯¢é—®å®ä½“
      const response = await chatController.processMessage({
        conversationId: testConversationId,
        userId: testUserId,
        message: 'å°å¼ æ˜¯åšä»€ä¹ˆå·¥ä½œçš„ï¼Ÿ'
      });
      
      expect(response.content).toContain('ç¨‹åºå‘˜');
      expect(response.metadata.usedEntities).toContainEqual(
        expect.objectContaining({ name: 'å°å¼ ', type: 'person' })
      );
    });
    
    test('should build relationships between entities', async () => {
      await chatController.processMessage({
        conversationId: testConversationId,
        userId: testUserId,
        message: 'å°æå’Œå°å¼ æ˜¯å¥½æœ‹å‹ï¼Œä»–ä»¬ç»å¸¸ä¸€èµ·å·¥ä½œã€‚'
      });
      
      const entityGraph = chatController.entityGraphManager;
      const liRelated = entityGraph.getRelatedEntities('å°æ');
      
      expect(liRelated).toContainEqual(
        expect.objectContaining({
          entity: expect.objectContaining({ name: 'å°å¼ ' }),
          relationship: expect.objectContaining({ type: 'knows' })
        })
      );
    });
  });
  
  describe('Context Compression and Retrieval', () => {
    test('should compress long conversations while preserving key information', async () => {
      // åˆ›å»ºé•¿å¯¹è¯
      const longConversation = generateLongConversation(50); // 50æ¡æ¶ˆæ¯
      
      const compressor = new SmartContextCompressor();
      const compressed = await compressor.compress(longConversation, {
        maxTokens: 1000,
        preserveEntities: ['å°æ', 'é¡¹ç›®A']
      });
      
      expect(compressed.compressed).toBe(true);
      expect(compressed.compressionRatio).toBeGreaterThan(2);
      expect(compressed.messages.some(m => m.content.includes('å°æ'))).toBe(true);
    });
    
    test('should retrieve relevant context based on semantic similarity', async () => {
      // å­˜å‚¨å¤šä¸ªä¸åŒä¸»é¢˜çš„æ¶ˆæ¯
      await storeTestMessages([
        { content: 'ä»Šå¤©å¤©æ°”å¾ˆå¥½', topic: 'weather' },
        { content: 'é¡¹ç›®è¿›å±•é¡ºåˆ©', topic: 'work' },
        { content: 'å‘¨æœ«å»çˆ¬å±±', topic: 'leisure' }
      ]);
      
      const vectorMemory = new VectorMemoryStore();
      const results = await vectorMemory.search('å·¥ä½œæ€ä¹ˆæ ·ï¼Ÿ');
      
      expect(results[0].text).toContain('é¡¹ç›®');
      expect(results[0].similarity).toBeGreaterThan(0.6);
    });
  });
  
  describe('Multi-Layer Memory System', () => {
    test('should store and retrieve from different memory layers', async () => {
      const multiLayerMemory = new MultiLayerMemory();
      
      // å­˜å‚¨åˆ°ä¸åŒå±‚
      await multiLayerMemory.store(testConversationId, {
        role: 'user',
        content: 'æˆ‘ä»Šå¤©å¿ƒæƒ…ä¸é”™'
      });
      
      // æ£€ç´¢æ—¶åº”è¯¥èƒ½ä»çŸ­æœŸè®°å¿†ä¸­æ‰¾åˆ°
      const shortTermResults = await multiLayerMemory.retrieve(
        testConversationId, 
        'æˆ‘çš„å¿ƒæƒ…',
        { includeShortTerm: true, includeLongTerm: false }
      );
      
      expect(shortTermResults.length).toBeGreaterThan(0);
      expect(shortTermResults[0].content).toContain('å¿ƒæƒ…ä¸é”™');
    });
  });
  
  describe('Performance and Scalability', () => {
    test('should handle concurrent requests efficiently', async () => {
      const concurrentRequests = 10;
      const startTime = Date.now();
      
      const promises = Array(concurrentRequests).fill().map((_, i) => 
        chatController.processMessage({
          conversationId: `test-conv-${i}`,
          userId: testUserId,
          message: `æµ‹è¯•æ¶ˆæ¯ ${i}`
        })
      );
      
      const results = await Promise.all(promises);
      const endTime = Date.now();
      
      expect(results.length).toBe(concurrentRequests);
      expect(endTime - startTime).toBeLessThan(5000); // 5ç§’å†…å®Œæˆ
    });
    
    test('should maintain performance with large entity graphs', async () => {
      // åˆ›å»ºå¤§é‡å®ä½“å’Œå…³ç³»
      await createLargeEntityGraph(1000); // 1000ä¸ªå®ä½“
      
      const startTime = Date.now();
      const relatedEntities = chatController.entityGraphManager
        .getRelatedEntities('entity-500', 3);
      const endTime = Date.now();
      
      expect(endTime - startTime).toBeLessThan(100); // 100mså†…å®Œæˆ
      expect(relatedEntities.length).toBeGreaterThan(0);
    });
  });
});
```

---

## ğŸ“‹ å®æ–½å»ºè®®

### æ¨èå®æ–½è·¯å¾„

#### é˜¶æ®µ1ï¼šç´§æ€¥ä¿®å¤ (ä¼˜å…ˆçº§ï¼šğŸ”´ é«˜)
- **æ—¶é—´**: 1-2å¤©
- **ç›®æ ‡**: è§£å†³åŸºæœ¬çš„çŸ­æœŸè®°å¿†é—®é¢˜
- **å®æ–½**: æ–¹æ¡ˆä¸€ - å†…å­˜çº§å­˜å‚¨
- **æˆåŠŸæ ‡å‡†**: æµ‹è¯•é€šè¿‡ç‡ > 80%

#### é˜¶æ®µ2ï¼šæ¶æ„å®Œå–„ (ä¼˜å…ˆçº§ï¼šğŸŸ¡ ä¸­)
- **æ—¶é—´**: 1-2å‘¨
- **ç›®æ ‡**: å»ºç«‹å®Œæ•´çš„å¯¹è¯å†å²API
- **å®æ–½**: æ–¹æ¡ˆäºŒ - åç«¯APIå®ç°
- **æˆåŠŸæ ‡å‡†**: æ‰€æœ‰åŠŸèƒ½æµ‹è¯•é€šè¿‡ï¼Œæ”¯æŒæŒä¹…åŒ–

#### é˜¶æ®µ3ï¼šæ™ºèƒ½ä¼˜åŒ– (ä¼˜å…ˆçº§ï¼šğŸŸ¢ ä½)
- **æ—¶é—´**: 1-2æœˆ
- **ç›®æ ‡**: æä¾›é«˜çº§æ™ºèƒ½è®°å¿†èƒ½åŠ›
- **å®æ–½**: æ–¹æ¡ˆä¸‰ - æ™ºèƒ½ä¸Šä¸‹æ–‡ç®¡ç†
- **æˆåŠŸæ ‡å‡†**: æ”¯æŒå¤æ‚æ¨ç†ï¼Œç”¨æˆ·ä½“éªŒä¼˜ç§€

### ç«‹å³è¡ŒåŠ¨å»ºè®®

1. **é©¬ä¸Šå¼€å§‹æ–¹æ¡ˆä¸€**: 
   - ä¿®æ”¹ ChatController æ·»åŠ å†…å­˜å­˜å‚¨
   - ä»Šå¤©å†…å¯ä»¥çœ‹åˆ°æ”¹å–„æ•ˆæœ

2. **åŒæ­¥å‡†å¤‡æ–¹æ¡ˆäºŒ**:
   - è®¾è®¡internal APIæ¥å£
   - å‡†å¤‡æ•°æ®åº“schemaæ›´æ–°

3. **è§„åˆ’æ–¹æ¡ˆä¸‰**:
   - è°ƒç ”å‘é‡æ•°æ®åº“å’ŒAIæ¨¡å‹
   - è®¾è®¡æ™ºèƒ½ä¸Šä¸‹æ–‡æ¶æ„

### é£é™©è¯„ä¼°

- **æŠ€æœ¯é£é™©**: ä½ - è§£å†³æ–¹æ¡ˆç»è¿‡éªŒè¯
- **å®æ–½é£é™©**: ä½ - æ”¹åŠ¨èŒƒå›´å¯æ§  
- **æ€§èƒ½é£é™©**: ä¸­ - éœ€è¦ç›‘æ§å†…å­˜ä½¿ç”¨
- **ç”¨æˆ·ä½“éªŒé£é™©**: ä½ - æ˜¾è‘—æ”¹å–„é¢„æœŸ

---

## ğŸ“Š é¢„æœŸæ•ˆæœ

### æ–¹æ¡ˆä¸€å®æ–½å
- çŸ­æœŸè®°å¿†: 4/5 â­ (æ˜¾è‘—æ”¹å–„)
- é•¿ç¨‹è®°å¿†: 2/5 â­ (æœ‰é™æ”¹å–„)
- ä¸Šä¸‹æ–‡å…³è”: 4/5 â­ (æ˜¾è‘—æ”¹å–„)
- é€»è¾‘ä¸€è‡´æ€§: 4/5 â­ (æ˜¾è‘—æ”¹å–„)
- å¤šè½®æ¨ç†: 3/5 â­ (æ˜æ˜¾æ”¹å–„)

### æ–¹æ¡ˆäºŒå®æ–½å
- æ‰€æœ‰æŒ‡æ ‡è¾¾åˆ° 4-5/5 â­
- æ”¯æŒè·¨ä¼šè¯çš„é•¿æœŸè®°å¿†
- ç³»ç»Ÿç¨³å®šæ€§å¤§å¹…æå‡

### æ–¹æ¡ˆä¸‰å®æ–½å
- æ‰€æœ‰æŒ‡æ ‡è¾¾åˆ° 5/5 â­
- æ”¯æŒæ™ºèƒ½æ¨ç†å’Œå¤æ‚å¯¹è¯
- ç”¨æˆ·ä½“éªŒè¾¾åˆ°ä¸šç•Œé¢†å…ˆæ°´å¹³

---

## ğŸ“ è”ç³»ä¸æ”¯æŒ

å¦‚éœ€æŠ€æœ¯æ”¯æŒæˆ–å®æ–½æŒ‡å¯¼ï¼Œè¯·è”ç³»å¼€å‘å›¢é˜Ÿã€‚

**æ–‡æ¡£æ›´æ–°**ï¼šæ­¤æ–‡æ¡£å°†æ ¹æ®å®æ–½è¿›å±•æŒç»­æ›´æ–°ã€‚

---

---

## ğŸ”§ **ç³»ç»Ÿé›†æˆè¿‡ç¨‹ä¸­çš„ä¿®æ”¹è®°å½•**

> **ç‰¹åˆ«è¯´æ˜**: ä»¥ä¸‹è®°å½•äº†ai-serviceä¸HearTalkåˆå¹¶åçš„æ‰€æœ‰ç³»ç»Ÿä¿®æ”¹

### **é˜¶æ®µä¸€ï¼šAIæœåŠ¡åˆå§‹é›†æˆ (2025-09-13å®Œæˆ)**

#### **1. æ–°å¢å®Œæ•´AIæœåŠ¡æ¨¡å—**
- **ä½ç½®**: `/Users/lulu/Documents/Work/ai_chat_v2/ccpm/ai-service/`
- **è§„æ¨¡**: 47ä¸ªæ–°å¢æ–‡ä»¶ï¼Œ0ä¸ªç°æœ‰æ–‡ä»¶ä¿®æ”¹
- **ç‰¹ç‚¹**: 100% APIå‘åå…¼å®¹ï¼Œé›¶ä¿®æ”¹æ›¿æ¢

**æ ¸å¿ƒæ–°å¢æ–‡ä»¶ç»“æ„**:
```
ai-service/
â”œâ”€â”€ src/controllers/ChatController.js       # å¯¹è¯æ§åˆ¶å™¨
â”œâ”€â”€ src/services/ReasoningEnhancer.js      # Chain-of-Thoughtæ¨ç†
â”œâ”€â”€ src/services/BasicRouter.js            # æ™ºèƒ½è·¯ç”±å¼•æ“
â”œâ”€â”€ src/services/ByteplusProvider.js       # Byteplusé›†æˆ
â”œâ”€â”€ src/middleware/AuthMiddleware.js       # JWTè®¤è¯ä¸­é—´ä»¶
â”œâ”€â”€ src/utils/ContextManager.js            # ä¸Šä¸‹æ–‡ç®¡ç†å™¨
â””â”€â”€ package.json                           # é¡¹ç›®ä¾èµ–é…ç½®
```

#### **2. ç¯å¢ƒé…ç½®æ ‡å‡†åŒ–**
```env
# æ–°å¢æ ‡å‡†åŒ–ç¯å¢ƒå˜é‡
HEARTALK_BACKEND_URL=http://localhost:8000
HEARTALK_API_KEY=dev_heartalk_api_key_placeholder
BYTEPLUS_AMI_CHAT_EP=ep-20250819170822-q2vnf
BYTEPLUS_AMI_WORK_ASSISTANT_EP=ep-20250826180754-nwjhn
```

### **é˜¶æ®µäºŒï¼šè°ƒè¯•å’Œå…¼å®¹æ€§ä¿®å¤ (2025-09-18)**

#### **1. è®¤è¯ç™½åå•æ‰©å±•**
**æ–‡ä»¶**: `ai-service/src/middleware/AuthMiddleware.js`

**ä¿®æ”¹å†…å®¹**:
```javascript
// ä¿®æ”¹å‰ (ccpmç‰ˆæœ¬)
this.whitelistPaths = [
  '/',
  '/health',
  '/api/v1/providers',
  '/api/v1/models'
];

// ä¿®æ”¹å (HEARTALK-BEç‰ˆæœ¬)
this.whitelistPaths = [
  '/',
  '/health',
  '/api/v1/health',           // æ–°å¢ï¼šå¥åº·æ£€æŸ¥
  '/api/v1/chat/generate',    // æ–°å¢ï¼šèŠå¤©ç”Ÿæˆ
  '/api/v1/chat/stream',      // æ–°å¢ï¼šæµå¼èŠå¤©
  '/api/v1/providers',
  '/api/v1/models'
];
```

**ä¿®æ”¹åŸå› **: è§£å†³503é”™è¯¯ - AIæœåŠ¡è®¤è¯ä¸­é—´ä»¶é˜»æ­¢èŠå¤©ç«¯ç‚¹è®¿é—®

#### **2. å¥åº·æ£€æŸ¥æ ¼å¼å…¼å®¹**
**æ–‡ä»¶**: `ai-service/src/routes/api.js`

**ä¿®æ”¹å†…å®¹**:
```javascript
// ä¿®æ”¹å‰
res.json(healthData);

// ä¿®æ”¹å
res.json({
  data: healthData  // åŒ…è£…ä¸ºåç«¯æœŸæœ›çš„æ ¼å¼
});
```

**ä¿®æ”¹åŸå› **: åç«¯`aiClient.validateConnection()`æœŸæœ›`{data: {status: 'healthy'}}`æ ¼å¼

#### **3. OpenAIæ ¼å¼APIå…¼å®¹**
**æ–‡ä»¶**: `ai-service/src/controllers/ChatController.js`

**ä¿®æ”¹å†…å®¹**:
```javascript
// æ–°å¢ï¼šæ”¯æŒOpenAIæ ¼å¼éªŒè¯
validateChatRequest(body) {
  if (body.messages && Array.isArray(body.messages)) {
    // OpenAIæ ¼å¼éªŒè¯é€»è¾‘
    return { valid: true, format: 'openai' };
  }
  // åŸæœ‰æ ¼å¼éªŒè¯...
  return { valid: true, format: 'legacy' };
}

// æ–°å¢ï¼šåŒæ ¼å¼å¤„ç†é€»è¾‘
if (validationResult.format === 'openai') {
  const userMessages = req.body.messages.filter(msg => msg.role === 'user');
  message = userMessages[userMessages.length - 1]?.content || '';
  // ...
}
```

**ä¿®æ”¹åŸå› **: æ”¯æŒåç«¯å‘é€çš„æ ‡å‡†OpenAIæ ¼å¼è¯·æ±‚

### **é˜¶æ®µä¸‰ï¼šæœ¬åœ°éƒ¨ç½²é…ç½®å·®å¼‚**

#### **1. HEARTALK-BEé¡¹ç›®ä¸“ç”¨æ–‡ä»¶**
```
HEARTALK-BE/ai-service/
â”œâ”€â”€ .env.local                  # æœ¬åœ°æµ‹è¯•é…ç½® (æ–°å¢)
â”œâ”€â”€ logs/                       # è¿è¡Œæ—¶æ—¥å¿—ç›®å½•
â”‚   â”œâ”€â”€ app.log
â”‚   â”œâ”€â”€ error.log
â”‚   â”œâ”€â”€ exceptions.log
â”‚   â””â”€â”€ rejections.log
â””â”€â”€ .env                        # Dockerç¯å¢ƒé…ç½®
```

#### **2. é…ç½®å·®å¼‚å¯¹æ¯”**
| é…ç½®é¡¹ | ccpmç‰ˆæœ¬ | HEARTALK-BEç‰ˆæœ¬ | å·®å¼‚è¯´æ˜ |
|--------|----------|-----------------|----------|
| `HOST` | `localhost` | `0.0.0.0` | Dockerå®¹å™¨ç½‘ç»œ |
| `HEARTALK_BACKEND_URL` | `http://localhost:8000` | `http://backend:8000` | DockeræœåŠ¡åè§£æ |
| `LOG_LEVEL` | `debug` | `info` | ç”Ÿäº§ç¯å¢ƒæ—¥å¿—çº§åˆ« |
| `CORS_ORIGINS` | æœªè®¾ç½® | `http://localhost:3000,http://localhost:8000` | è·¨åŸŸé…ç½® |

### **åç«¯ç³»ç»ŸçŠ¶æ€ç¡®è®¤**

#### **âœ… æ— éœ€ä¿®æ”¹çš„åç«¯éƒ¨åˆ†**
- **åŸåˆ™**: 100%å‘åå…¼å®¹è®¾è®¡
- **éªŒè¯**: æ‰€æœ‰ç°æœ‰APIè°ƒç”¨æ­£å¸¸å·¥ä½œ
- **æ¶æ„**: AIæœåŠ¡ä½œä¸ºç‹¬ç«‹å¾®æœåŠ¡ï¼Œé€šè¿‡APIè°ƒç”¨é›†æˆ

#### **âŒ å‘ç°çš„æ¶æ„ç¼ºå¤±**
- **ç¼ºå¤±**: `/internal/api/v1/conversations/:id/history` APIç«¯ç‚¹
- **å½±å“**: å¯¼è‡´å¯¹è¯è®°å¿†åŠŸèƒ½å¤±æ•ˆ
- **çŠ¶æ€**: å·²è®°å½•åœ¨ä¼˜åŒ–æ–¹æ¡ˆä¸­ï¼Œå¾…å®æ–½

### **Dockerå’Œéƒ¨ç½²é…ç½®**

#### **docker-compose.yml ç°æœ‰é…ç½®**
```yaml
# å·²å­˜åœ¨çš„AIæœåŠ¡é…ç½®
ai-service:
  build:
    context: ./ai-service
    dockerfile: Dockerfile.dev
  container_name: heartalk-ai-service
  env_file:
    - ./ai-service/.env
  ports:
    - "8001:8001"
  depends_on:
    - backend
```

### **ä¿®æ”¹ç»Ÿè®¡æ€»ç»“**

| ä¿®æ”¹ç±»å‹ | ccpmâ†’HEARTALK-BE | ä»Šæ—¥è°ƒè¯•ä¿®æ”¹ | æ€»è®¡ |
|----------|------------------|--------------|------|
| æ–°å¢æ–‡ä»¶ | 47ä¸ª | 1ä¸ª(.env.local) | 48ä¸ª |
| ä¿®æ”¹æ–‡ä»¶ | 0ä¸ª | 2ä¸ª(AuthMiddleware.js, api.js) | 2ä¸ª |
| åˆ é™¤æ–‡ä»¶ | 0ä¸ª | 0ä¸ª | 0ä¸ª |
| é…ç½®è°ƒæ•´ | 4ä¸ªç¯å¢ƒæ–‡ä»¶ | ç™½åå•+å¥åº·æ£€æŸ¥æ ¼å¼ | 6é¡¹ |

### **å…³é”®æŠ€æœ¯å†³ç­–è®°å½•**

1. **è®¤è¯ç­–ç•¥**: é‡‡ç”¨ç™½åå•æœºåˆ¶è€Œéå®Œå…¨è·³è¿‡è®¤è¯
2. **APIå…¼å®¹**: æ”¯æŒåŒæ ¼å¼(OpenAI + åŸæœ‰æ ¼å¼)è€Œéå¼ºåˆ¶ç»Ÿä¸€  
3. **å¥åº·æ£€æŸ¥**: ä¿®æ”¹AIæœåŠ¡è¾“å‡ºæ ¼å¼è€Œéä¿®æ”¹åç«¯éªŒè¯é€»è¾‘
4. **éƒ¨ç½²æ–¹å¼**: Dockerå®¹å™¨åŒ–éƒ¨ç½²ï¼Œä¿æŒæœåŠ¡éš”ç¦»

---

*æœ¬æŠ¥å‘ŠåŸºäº2025å¹´9æœˆ18æ—¥çš„å®é™…ç”¨æˆ·æµ‹è¯•å’ŒæŠ€æœ¯åˆ†æï¼Œä¸ºHearTalk AIç³»ç»Ÿçš„å¯¹è¯è®°å¿†åŠŸèƒ½ä¼˜åŒ–æä¾›å…¨é¢çš„æŠ€æœ¯æŒ‡å¯¼ã€‚*